"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEngineV3 = exports.DendronEngineV3 = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const notesFileSystemCache_1 = require("./cache/notesFileSystemCache");
const config_1 = require("./config");
const NoteParserV2_1 = require("./drivers/file/NoteParserV2");
const schemaParser_1 = require("./drivers/file/schemaParser");
const storev2_1 = require("./drivers/file/storev2");
// import { AnchorUtils, LinkUtils } from "./markdown";
const unified_1 = require("@dendronhq/unified");
const store_1 = require("./store");
const hooks_1 = require("./topics/hooks");
const engineUtils_1 = require("./utils/engineUtils");
class DendronEngineV3 extends common_all_1.EngineV3Base {
    constructor(props) {
        super(props.noteStore, props.logger);
        this.wsRoot = props.wsRoot;
        this.configRoot = props.wsRoot;
        this.props = props;
        this.fuseEngine = new common_all_1.FuseEngine({
            fuzzThreshold: common_all_1.ConfigUtils.getLookup(props.config).note.fuzzThreshold,
        });
        this.links = [];
        this.config = props.config;
        this._vaults = props.vaults;
        const hooks = common_all_1.ConfigUtils.getWorkspace(props.config).hooks || {
            onCreate: [],
        };
        this.hooks = hooks;
        this._fileStore = props.fileStore;
        this._noteStore = props.noteStore;
        this._schemaStore = props.schemaStore;
        // TODO: remove after migration
        this.store = new storev2_1.FileStorage({
            engine: this,
            logger: this.logger,
        });
    }
    static create({ wsRoot, logger }) {
        const LOGGER = logger || (0, common_server_1.createLogger)();
        const { error, data: config } = config_1.DConfig.readConfigAndApplyLocalOverrideSync(wsRoot);
        if (error) {
            LOGGER.error((0, common_all_1.stringifyError)(error));
        }
        const fileStore = new store_1.NodeJSFileStore();
        return new DendronEngineV3({
            wsRoot,
            vaults: common_all_1.ConfigUtils.getVaults(config),
            forceNew: true,
            noteStore: new common_all_1.NoteStore(fileStore, new common_all_1.NoteMetadataStore(), common_all_1.URI.file(wsRoot)),
            schemaStore: new common_all_1.SchemaStore(fileStore, new common_all_1.SchemaMetadataStore(), common_all_1.URI.parse(wsRoot)),
            fileStore,
            mode: "fuzzy",
            logger: LOGGER,
            config,
        });
    }
    static instance({ wsRoot }) {
        if (!DendronEngineV3._instance) {
            DendronEngineV3._instance = DendronEngineV3.create({ wsRoot });
        }
        return DendronEngineV3._instance;
    }
    /**
     * @deprecated
     * For accessing a specific note by id, see {@link DendronEngineV3.getNote}.
     * If you need all notes, avoid modifying any note as this will cause unintended changes on the store side
     */
    get notes() {
        return this.store.notes;
    }
    /**
     * @deprecated see {@link DendronEngineV3.findNotes}
     */
    get noteFnames() {
        return this.store.noteFnames;
    }
    /**
     * @deprecated
     * For accessing a specific schema by id, see {@link DendronEngineV3.getSchema}.
     * If you need all schemas, avoid modifying any schema as this will cause unintended changes on the store side
     */
    get schemas() {
        return this.store.schemas;
    }
    get vaults() {
        return this._vaults;
    }
    set vaults(vaults) {
        this._vaults = vaults;
    }
    /**
     * Does not throw error but returns it
     */
    async init() {
        try {
            const { data: schemas, error: schemaErrors } = await this.initSchema();
            if (lodash_1.default.isUndefined(schemas)) {
                return {
                    error: common_all_1.DendronError.createFromStatus({
                        message: "No schemas found",
                        status: common_all_1.ERROR_STATUS.UNKNOWN,
                        severity: common_all_1.ERROR_SEVERITY.FATAL,
                    }),
                };
            }
            const schemaDict = {};
            schemas.forEach((schema) => {
                schemaDict[schema.root.id] = schema;
            });
            const { data: notes, error: noteErrors } = await this.initNotes(schemaDict);
            if (lodash_1.default.isUndefined(notes)) {
                return {
                    error: common_all_1.DendronError.createFromStatus({
                        message: "No notes found",
                        status: common_all_1.ERROR_STATUS.UNKNOWN,
                        severity: common_all_1.ERROR_SEVERITY.FATAL,
                    }),
                };
            }
            this.fuseEngine.replaceNotesIndex(notes);
            this.fuseEngine.replaceSchemaIndex(schemaDict);
            const bulkWriteOpts = lodash_1.default.values(notes).map((note) => {
                const noteMeta = lodash_1.default.omit(note, ["body", "contentHash"]);
                return { key: note.id, noteMeta };
            });
            this._noteStore.bulkWriteMetadata(bulkWriteOpts);
            const bulkWriteSchemaOpts = schemas.map((schema) => {
                return { key: schema.root.id, schema };
            });
            this._schemaStore.bulkWriteMetadata(bulkWriteSchemaOpts);
            const hookErrors = [];
            this.hooks.onCreate = this.hooks.onCreate.filter((hook) => {
                const { valid, error } = hooks_1.HookUtils.validateHook({
                    hook,
                    wsRoot: this.wsRoot,
                });
                if (!valid && error) {
                    this.logger.error({ msg: "bad hook", hook, error });
                    hookErrors.push(error);
                }
                return valid;
            });
            let allErrors = noteErrors
                ? hookErrors.concat(noteErrors.errors)
                : hookErrors;
            allErrors = schemaErrors
                ? allErrors.concat(schemaErrors.errors)
                : allErrors;
            let error;
            switch (lodash_1.default.size(allErrors)) {
                case 0: {
                    error = null;
                    break;
                }
                case 1: {
                    error = new common_all_1.DendronError(allErrors[0]);
                    break;
                }
                default:
                    error = new common_all_1.DendronCompositeError(allErrors);
            }
            this.logger.info({
                ctx: "init:ext",
                error,
                storeError: allErrors,
                hookErrors,
            });
            return {
                error,
                data: {
                    notes,
                    schemas: schemaDict,
                    wsRoot: this.wsRoot,
                    vaults: this.vaults,
                    config: this.config,
                },
            };
        }
        catch (error) {
            const { message, stack, status } = error;
            const payload = { message, stack };
            return {
                error: common_all_1.DendronError.createPlainError({
                    payload,
                    message,
                    status,
                    severity: common_all_1.ERROR_SEVERITY.FATAL,
                }),
            };
        }
    }
    /**
     * See {@link DEngine.writeNote}
     */
    async writeNote(note, opts) {
        let changes = [];
        let error = null;
        const ctx = "DEngine:writeNewNote";
        this.logger.info({
            ctx,
            msg: `enter with ${opts}`,
            note: common_all_1.NoteUtils.toLogObj(note),
        });
        // Update links/anchors based on note body
        // TODO: update backlinks as well
        engineUtils_1.EngineUtils.refreshNoteLinksAndAnchors({
            note,
            engine: this,
        });
        // Apply hooks
        if ((opts === null || opts === void 0 ? void 0 : opts.runHooks) === false) {
            this.logger.info({
                ctx,
                msg: "hooks disabled for write",
            });
        }
        else {
            const hooks = lodash_1.default.filter(this.hooks.onCreate, (hook) => common_all_1.NoteUtils.match({ notePath: note.fname, pattern: hook.pattern }));
            const resp = await lodash_1.default.reduce(hooks, async (notePromise, hook) => {
                const { note } = await notePromise;
                const script = hooks_1.HookUtils.getHookScriptPath({
                    wsRoot: this.wsRoot,
                    basename: hook.id + ".js",
                });
                return hooks_1.HookUtils.requireHook({
                    note,
                    fpath: script,
                    wsRoot: this.wsRoot,
                });
            }, Promise.resolve({ note })).catch((err) => new common_all_1.DendronError({
                severity: common_all_1.ERROR_SEVERITY.MINOR,
                message: "error with hook",
                payload: (0, common_all_1.stringifyError)(err),
            }));
            if (resp instanceof common_all_1.DendronError) {
                error = resp;
                this.logger.error({ ctx, error: (0, common_all_1.stringifyError)(error) });
            }
            else {
                const valResp = common_all_1.NoteUtils.validate(resp.note);
                if (valResp instanceof common_all_1.DendronError) {
                    error = valResp;
                    this.logger.error({ ctx, error: (0, common_all_1.stringifyError)(error) });
                }
                else {
                    note = resp.note;
                    this.logger.info({ ctx, msg: "fin:RunHooks", payload: resp.payload });
                }
            }
        }
        // Check if another note with same fname and vault exists
        const resp = await this._noteStore.find({
            fname: note.fname,
            vault: note.vault,
        });
        const existingNote = resp.data ? resp.data[0] : undefined;
        // If a note exists with a different id but same fname/vault, then we throw an error unless its a stub or override is set
        if (existingNote && existingNote.id !== note.id) {
            // If note is a stub or client wants to override existing note, we need to update parent/children relationships since ids are different
            // The parent of this note needs to have the old note removed (because the id is now different)
            // The new note needs to have the old note's children
            if (existingNote.stub || (opts === null || opts === void 0 ? void 0 : opts.overrideExisting)) {
                // make sure existing note actually has a parent.
                if (!existingNote.parent) {
                    // TODO: We should be able to handle rewriting of root. This happens
                    // with certain operations such as Doctor FixFrontmatter
                    return {
                        error: new common_all_1.DendronError({
                            status: common_all_1.ERROR_STATUS.NO_PARENT_FOR_NOTE,
                            message: `No parent found for ${existingNote.fname}`,
                        }),
                    };
                }
                const parentResp = await this._noteStore.get(existingNote.parent);
                if (parentResp.error) {
                    return {
                        error: new common_all_1.DendronError({
                            status: common_all_1.ERROR_STATUS.NO_PARENT_FOR_NOTE,
                            message: `No parent found for ${existingNote.fname}`,
                            innerError: parentResp.error,
                        }),
                    };
                }
                // Save the state of the parent to later record changed entry.
                const parent = parentResp.data;
                const prevParentState = { ...parent };
                // Update existing note's parent so that it doesn't hold the existing note's id as children
                common_all_1.DNodeUtils.removeChild(parent, existingNote);
                // Update parent note of existing note so that the newly created note is a child
                common_all_1.DNodeUtils.addChild(parent, note);
                // Add an entry for the updated parent
                changes.push({
                    prevNote: prevParentState,
                    note: parent,
                    status: "update",
                });
                // Move children to new note
                changes = changes.concat(await this.updateChildrenWithNewParent(existingNote, note));
                // Delete the existing note from metadata store. Since fname/vault are the same, no need to touch filesystem
                changes.push({ note: existingNote, status: "delete" });
            }
            else {
                return {
                    error: new common_all_1.DendronError({
                        message: `Cannot write note with id ${note.id}. Note ${existingNote.id} with same fname and vault exists`,
                    }),
                };
            }
        }
        else if (!existingNote && !(opts === null || opts === void 0 ? void 0 : opts.noAddParent)) {
            // If existing note does not exist, check if we need to add parents
            // eg. if user created `baz.one.two` and neither `baz` or `baz.one` exist, then they need to be created
            // this is the default behavior
            const ancestorResp = await this.findClosestAncestor(note.fname, note.vault);
            if (ancestorResp.data) {
                const ancestor = ancestorResp.data;
                const prevAncestorState = { ...ancestor };
                // Create stubs for any uncreated notes between ancestor and note
                const stubNodes = common_all_1.NoteUtils.createStubs(ancestor, note);
                stubNodes.forEach((stub) => {
                    changes.push({
                        status: "create",
                        note: stub,
                    });
                });
                changes.push({
                    status: "update",
                    prevNote: prevAncestorState,
                    note: ancestor,
                });
            }
            else {
                this.logger.error({
                    ctx,
                    msg: `Unable to find ancestor for note ${note.fname}`,
                });
                return { error: ancestorResp.error };
            }
        }
        // Write to metadata store and/or filesystem
        const writeResp = (opts === null || opts === void 0 ? void 0 : opts.metaOnly)
            ? await this._noteStore.writeMetadata({ key: note.id, noteMeta: note })
            : await this._noteStore.write({ key: note.id, note });
        if (writeResp.error) {
            return {
                error: new common_all_1.DendronError({
                    message: `Unable to write note ${note.id}`,
                    severity: common_all_1.ERROR_SEVERITY.MINOR,
                    payload: writeResp.error,
                }),
            };
        }
        // Add schema if this is a new note
        if (existingNote) {
            note.schema = existingNote.schema;
        }
        else {
            const domainName = common_all_1.DNodeUtils.domainName(note.fname);
            const maybeSchemaModule = await this._schemaStore.getMetadata(domainName);
            if (maybeSchemaModule.data) {
                const schemaMatch = common_all_1.SchemaUtils.findSchemaFromModule({
                    notePath: note.fname,
                    schemaModule: maybeSchemaModule.data,
                });
                if (schemaMatch) {
                    this.logger.info({
                        ctx,
                        msg: "pre:addSchema",
                    });
                    const { schema, schemaModule } = schemaMatch;
                    common_all_1.NoteUtils.addSchema({ note, schema, schemaModule });
                }
            }
        }
        if (existingNote && existingNote.id === note.id) {
            // If a note exist with the same id, then we treat this as an update
            changes.push({ prevNote: existingNote, note, status: "update" });
        }
        else {
            changes.push({ note, status: "create" });
        }
        // Propragate metadata for all other changes
        await this.fuseEngine.updateNotesIndex(changes);
        await this.updateNoteMetadataStore(changes);
        this.logger.info({
            ctx,
            msg: "exit",
            changed: changes.map((n) => common_all_1.NoteUtils.toLogObj(n.note)),
        });
        return {
            error,
            data: changes,
        };
    }
    /**
     * See {@link DEngine.renameNote}
     *
     * TODO: make atomic
     */
    async renameNote(opts) {
        const ctx = "DEngine:renameNote";
        const { oldLoc, newLoc } = opts;
        this.logger.info({ ctx, msg: "enter", opts });
        const oldVault = common_all_1.VaultUtils.getVaultByName({
            vaults: this.vaults,
            vname: oldLoc.vaultName,
        });
        if (!oldVault) {
            return {
                error: new common_all_1.DendronError({
                    message: "vault not found for old location",
                }),
            };
        }
        const oldNote = (await this.findNotes({
            fname: oldLoc.fname,
            vault: oldVault,
        }))[0];
        if (!oldNote) {
            return {
                error: new common_all_1.DendronError({
                    status: common_all_1.ERROR_STATUS.DOES_NOT_EXIST,
                    message: `Unable to rename note "${oldLoc.fname}" in vault "${common_all_1.VaultUtils.getName(oldVault)}".` +
                        ` Check that this note exists, and make sure it has a frontmatter with an id.`,
                    severity: common_all_1.ERROR_SEVERITY.FATAL,
                }),
            };
        }
        const newNoteTitle = common_all_1.NoteUtils.isDefaultTitle(oldNote)
            ? common_all_1.NoteUtils.genTitle(newLoc.fname)
            : oldNote.title;
        // If the rename operation is changing the title and the caller did not tell us to use a special alias, calculate the alias change.
        // The aliases of links to this note will only change if they match the old note's title.
        if (newNoteTitle !== oldNote.title && !oldLoc.alias && !newLoc.alias) {
            oldLoc.alias = oldNote.title;
            newLoc.alias = newNoteTitle;
        }
        // Get list of notes referencing old note. We need to rename those references
        const notesReferencingOld = lodash_1.default.uniq(oldNote.links
            .map((link) => {
            if (link.type === "backlink") {
                return link.from.id;
            }
            else {
                return undefined;
            }
        })
            .filter(common_all_1.isNotUndefined));
        const linkNotesResp = await this._noteStore.bulkGet(notesReferencingOld);
        // update note body of all notes that have changed
        const notesToUpdate = linkNotesResp
            .map((resp) => {
            if (resp.error) {
                this.logger.error({
                    ctx,
                    message: `Unable to find note linking to ${oldNote.fname}`,
                    error: (0, common_all_1.stringifyError)(resp.error),
                });
                return undefined;
            }
            else {
                return this.processNoteChangedByRename({
                    note: resp.data,
                    oldLoc,
                    newLoc,
                });
            }
        })
            .filter(common_all_1.isNotUndefined);
        this.logger.info({ ctx, msg: "updateAllNotes:pre" });
        const writeResp = await this.bulkWriteNotes({ notes: notesToUpdate });
        if (writeResp.error) {
            return {
                error: new common_all_1.DendronError({
                    message: `Unable to update note link references`,
                    innerError: writeResp.error,
                }),
            };
        }
        let notesChangedEntries = writeResp.data;
        /**
         * If the event source is not engine(ie: vscode rename context menu), we do not want to
         * delete the original files. We just update the references on onWillRenameFiles and return.
         */
        const newNote = {
            ...oldNote,
            fname: newLoc.fname,
            vault: common_all_1.VaultUtils.getVaultByName({
                vaults: this.vaults,
                vname: newLoc.vaultName,
            }),
            title: newNoteTitle,
            // when renaming, we are moving a note into a completely different hierarchy.
            // we are not concerned with the children it has, so the new note
            // shouldn't inherit the old note's children.
            children: [],
        };
        // NOTE: order matters. need to delete old note, otherwise can't write new note
        this.logger.info({
            ctx,
            msg: "deleteNote:meta:pre",
            note: common_all_1.NoteUtils.toLogObj(oldNote),
        });
        if (oldNote.fname.toLowerCase() === newNote.fname.toLowerCase() &&
            common_all_1.VaultUtils.isEqual(oldNote.vault, newNote.vault, this.wsRoot)) {
            // The file is being renamed to itself. We do this to rename a header.
            this.logger.info({ ctx, msg: "Renaming the file to same name" });
            // Add the old note's children back in
            newNote.children = oldNote.children;
        }
        else {
            // The file is being renamed to a new file. Delete old file first
            this.logger.info({ ctx, msg: "Renaming the file to a new name" });
            const out = await this.deleteNote(oldNote.id, {
                metaOnly: opts.metaOnly,
            });
            if (out.error) {
                return {
                    error: new common_all_1.DendronError({
                        message: `Unable to delete note "${oldNote.fname}" in vault "${common_all_1.VaultUtils.getName(oldNote.vault)}".` +
                            ` Check that this note exists, and make sure it has a frontmatter with an id.`,
                        severity: common_all_1.ERROR_SEVERITY.FATAL,
                        innerError: out.error,
                    }),
                };
            }
            if (out.data) {
                notesChangedEntries = out.data.concat(notesChangedEntries);
            }
        }
        this.logger.info({
            ctx,
            msg: "writeNewNote:pre",
            note: common_all_1.NoteUtils.toLogObj(newNote),
        });
        const out = await this.writeNote(newNote, { metaOnly: opts.metaOnly });
        if (out.error) {
            return {
                error: new common_all_1.DendronError({
                    message: `Unable to write new renamed note for ${newNote.fname}`,
                    innerError: out.error,
                }),
            };
        }
        if (out.data) {
            notesChangedEntries = notesChangedEntries.concat(out.data);
        }
        this.logger.info({ ctx, msg: "exit", opts, out: notesChangedEntries });
        return { data: notesChangedEntries, error: null };
    }
    /**
     * TODO: We should read config from file or from engine.config, not both.
     */
    async getConfig() {
        const cpath = config_1.DConfig.configPath(this.configRoot);
        const config = lodash_1.default.defaultsDeep((0, common_server_1.readYAML)(cpath), common_all_1.ConfigUtils.genDefaultConfig());
        return {
            error: null,
            data: config,
        };
    }
    /**
     * See {@link DEngine.getSchema}
     */
    async getSchema(id) {
        return this._schemaStore.getMetadata(id);
    }
    /**
     * See {@link DEngine.writeSchema}
     */
    async writeSchema(schema, opts) {
        const maybeSchema = await this._schemaStore.getMetadata(schema.root.id);
        if (opts === null || opts === void 0 ? void 0 : opts.metaOnly) {
            await this._schemaStore.writeMetadata({ key: schema.root.id, schema });
        }
        else {
            await this._schemaStore.write({ key: schema.root.id, schema });
        }
        // Remove existing schema from fuse engine first
        if (maybeSchema.data) {
            this.fuseEngine.removeSchemaFromIndex(maybeSchema.data);
        }
        this.fuseEngine.addSchemaToIndex(schema);
    }
    /**
     * See {@link DEngine.deleteSchema}
     */
    async deleteSchema(id, opts) {
        if (opts === null || opts === void 0 ? void 0 : opts.metaOnly) {
            await this._schemaStore.deleteMetadata(id);
        }
        else {
            await this._schemaStore.delete(id);
        }
        // TODO: rework this to make more efficient
        return this.init();
    }
    async info() {
        const version = common_server_1.NodeJSUtils.getVersionFromPkg();
        if (!version) {
            return {
                data: undefined,
                error: common_all_1.DendronError.createPlainError({
                    message: "Unable to read Dendron version",
                }),
            };
        }
        return {
            data: {
                version,
            },
            error: null,
        };
    }
    queryNotesSync() {
        throw Error("queryNotesSync not implemented");
    }
    /**
     * See {@link DEngine.querySchema}
     */
    async querySchema(queryString) {
        const ctx = "DEngine:querySchema";
        const schemaIds = this.fuseEngine
            .querySchema({ qs: queryString })
            .map((ent) => ent.id);
        const responses = await this._schemaStore.bulkGetMetadata(schemaIds);
        const schemas = responses.map((resp) => resp.data).filter(common_all_1.isNotUndefined);
        this.logger.info({ ctx, msg: "exit" });
        return {
            error: null,
            data: schemas,
        };
    }
    /**
     * See {@link DEngine.queryNotes}
     */
    async queryNotes(opts) {
        const ctx = "DEngine:queryNotes";
        const { qs, vault, onlyDirectChildren, originalQS } = opts;
        // Need to ignore this because the engine stringifies this property, so the types are incorrect.
        // @ts-ignore
        if ((vault === null || vault === void 0 ? void 0 : vault.selfContained) === "true" || (vault === null || vault === void 0 ? void 0 : vault.selfContained) === "false")
            vault.selfContained = vault.selfContained === "true";
        const noteIds = this.fuseEngine
            .queryNote({
            qs,
            onlyDirectChildren,
            originalQS,
        })
            .map((ent) => ent.id);
        if (noteIds.length === 0) {
            return { error: null, data: [] };
        }
        const responses = await this._noteStore.bulkGet(noteIds);
        let notes = responses.map((resp) => resp.data).filter(common_all_1.isNotUndefined);
        if (!lodash_1.default.isUndefined(vault)) {
            notes = notes.filter((ent) => {
                return common_all_1.VaultUtils.isEqual(vault, ent.vault, this.wsRoot);
            });
        }
        this.logger.info({ ctx, msg: "exit" });
        return {
            error: null,
            data: notes,
        };
    }
    async renderNote() {
        throw Error("renderNote not implemented");
    }
    async sync() {
        throw Error("sync not implemented");
    }
    async refreshNotes() {
        throw new Error("sync not implemented");
    }
    /**
     * @deprecated: Use {@link DEngine.writeNote}
     */
    async updateNote() {
        throw new Error("updateNote not implemented");
    }
    /**
     * @deprecated: Use {@link DEngine.writeSchema}
     */
    async updateSchema() {
        throw Error("updateSchema not implemented");
    }
    async writeConfig() {
        throw Error("writeConfig not implemented");
    }
    async addAccessTokensToPodConfig() {
        throw Error("addAccessTokensToPodConfig not implemented");
    }
    async getNoteBlocks() {
        throw Error("getNoteBlocks not implemented");
    }
    async getDecorations() {
        throw Error("getDecorations not implemented");
    }
    /**
     * @deprecated: Use {@link LinkUtils.findLinks}
     */
    async getLinks(opts) {
        const { type, note } = opts;
        return {
            data: unified_1.LinkUtils.findLinks({
                note,
                type,
                engine: this,
            }),
            error: null,
        };
    }
    /**
     * @deprecated: Use {@link AnchorUtils.findAnchors}
     */
    async getAnchors(opts) {
        return {
            data: unified_1.AnchorUtils.findAnchors({
                note: opts.note,
            }),
            error: null,
        };
    }
    async initSchema() {
        const ctx = "DEngine:initSchema";
        this.logger.info({ ctx, msg: "enter" });
        let errorList = [];
        const schemaResponses = await Promise.all(this.vaults.map(async (vault) => {
            const vpath = (0, common_server_1.vault2Path)({ vault, wsRoot: this.wsRoot });
            // Get list of files from filesystem
            const maybeFiles = await this._fileStore.readDir({
                root: common_all_1.URI.parse(vpath),
                include: ["*.schema.yml"],
            });
            if (maybeFiles.error || maybeFiles.data.length === 0) {
                // Keep initializing other vaults
                return {
                    error: new common_all_1.DendronCompositeError([
                        new common_all_1.DendronError({
                            message: `Unable to get schemas for vault ${common_all_1.VaultUtils.getName(vault)}`,
                            status: common_all_1.ERROR_STATUS.NO_SCHEMA_FOUND,
                            severity: common_all_1.ERROR_SEVERITY.MINOR,
                            payload: maybeFiles.error,
                        }),
                    ]),
                };
            }
            const schemaFiles = maybeFiles.data.map((entry) => entry.toString());
            this.logger.info({ ctx, schemaFiles });
            const { schemas, errors } = await new schemaParser_1.SchemaParser({
                wsRoot: this.wsRoot,
                logger: this.logger,
            }).parse(schemaFiles, vault);
            if (errors) {
                errorList = errorList.concat(errors);
            }
            return {
                data: schemas,
                error: lodash_1.default.isNull(errors) ? null : new common_all_1.DendronCompositeError(errors),
            };
        }));
        const errors = schemaResponses
            .flatMap((response) => response.error)
            .filter(common_all_1.isNotNull);
        return {
            error: errors.length > 0 ? new common_all_1.DendronCompositeError(errors) : null,
            data: schemaResponses
                .flatMap((response) => response.data)
                .filter(common_all_1.isNotUndefined),
        };
    }
    /**
     * Construct dictionary of NoteProps from workspace on filesystem
     *
     * For every vault on the filesystem, get list of files and convert each file to NoteProp
     * @returns NotePropsByIdDict
     */
    async initNotes(schemas) {
        const ctx = "DEngine:initNotes";
        this.logger.info({ ctx, msg: "enter" });
        let errors = [];
        let notesFname = {};
        const start = process.hrtime();
        const allNotesList = await Promise.all(this.vaults.map(async (vault) => {
            const vpath = (0, common_server_1.vault2Path)({ vault, wsRoot: this.wsRoot });
            // Get list of files from filesystem
            const maybeFiles = await this._fileStore.readDir({
                root: common_all_1.URI.file(vpath),
                include: ["*.md"],
            });
            if (maybeFiles.error) {
                // Keep initializing other vaults
                errors = errors.concat([
                    new common_all_1.DendronError({
                        message: `Unable to read notes for vault ${common_all_1.VaultUtils.getName(vault)}`,
                        severity: common_all_1.ERROR_SEVERITY.MINOR,
                        payload: maybeFiles.error,
                    }),
                ]);
                return {};
            }
            // Load cache from vault
            const cachePath = path_1.default.join(vpath, common_all_1.CONSTANTS.DENDRON_CACHE_FILE);
            const notesCache = new notesFileSystemCache_1.NotesFileSystemCache({
                cachePath,
                noCaching: this.config.noCaching,
                logger: this.logger,
            });
            const { data: notesDict, error } = await new NoteParserV2_1.NoteParserV2({
                cache: notesCache,
                engine: this,
                logger: this.logger,
            }).parseFiles(maybeFiles.data, vault, schemas);
            if (error) {
                errors = errors.concat(error === null || error === void 0 ? void 0 : error.errors);
            }
            if (notesDict) {
                const { notesById, notesByFname } = notesDict;
                notesFname = common_all_1.NoteFnameDictUtils.merge(notesFname, notesByFname);
                this.logger.info({
                    ctx,
                    vault,
                    numEntries: lodash_1.default.size(notesById),
                    numCacheUpdates: notesCache.numCacheMisses,
                });
                return notesById;
            }
            return {};
        }));
        const allNotes = Object.assign({}, ...allNotesList);
        const notesWithLinks = lodash_1.default.filter(allNotes, (note) => !lodash_1.default.isEmpty(note.links));
        this.addBacklinks({
            notesById: allNotes,
            notesByFname: notesFname,
        }, notesWithLinks);
        const duration = (0, common_server_1.getDurationMilliseconds)(start);
        this.logger.info({ ctx, msg: `time to init notes: "${duration}" ms` });
        return {
            data: allNotes,
            error: new common_all_1.DendronCompositeError(errors),
        };
    }
    /**
     * Create and add backlinks from all notes with a link pointing to another note
     */
    addBacklinks(noteDicts, notesWithLinks) {
        notesWithLinks.forEach((noteFrom) => {
            try {
                noteFrom.links.forEach((link) => {
                    var _a;
                    const fname = (_a = link.to) === null || _a === void 0 ? void 0 : _a.fname;
                    // Note referencing itself does not count as backlink
                    if (fname && fname !== noteFrom.fname) {
                        const notes = common_all_1.NoteDictsUtils.findByFname(fname, noteDicts);
                        notes.forEach((noteTo) => {
                            common_all_1.NoteUtils.addBacklink({
                                from: noteFrom,
                                to: noteTo,
                                link,
                            });
                        });
                    }
                });
            }
            catch (err) {
                const error = (0, common_all_1.error2PlainObject)(err);
                this.logger.error({ error, noteFrom, message: "issue with backlinks" });
            }
        });
    }
    /**
     * Recursively search through fname to find next available ancestor note.
     *
     * E.g, if fpath = "baz.foo.bar", search for "baz.foo", then "baz", then "root" until first valid note is found
     * @param fpath of note to find ancestor of
     * @param vault of ancestor note
     * @returns closest ancestor note
     */
    async findClosestAncestor(fpath, vault) {
        const dirname = common_all_1.DNodeUtils.dirName(fpath);
        // Reached the end, must be root note
        if (dirname === "") {
            const rootResp = await this._noteStore.find({ fname: "root", vault });
            if (rootResp.error || rootResp.data.length === 0) {
                return {
                    error: common_all_1.DendronError.createFromStatus({
                        status: common_all_1.ERROR_STATUS.NO_ROOT_NOTE_FOUND,
                        message: `No root found for ${fpath}.`,
                        innerError: rootResp.error,
                        severity: common_all_1.ERROR_SEVERITY.MINOR,
                    }),
                };
            }
            return { data: rootResp.data[0] };
        }
        const parentResp = await this._noteStore.find({ fname: dirname, vault });
        if (parentResp.data && parentResp.data.length > 0) {
            return { data: parentResp.data[0] };
        }
        else {
            return this.findClosestAncestor(dirname, vault);
        }
    }
    /**
     * Update the links inside this note that need to be updated for the rename from `oldLoc` to `newLoc`
     * Will update the note in place and return note if something has changed
     */
    processNoteChangedByRename({ note, oldLoc, newLoc, }) {
        const prevNote = lodash_1.default.cloneDeep(note);
        const foundLinks = unified_1.LinkUtils.findLinksFromBody({
            note,
            engine: this,
            filter: { loc: oldLoc },
        });
        // important to order by position since we replace links and this affects
        // subsequent links
        let allLinks = lodash_1.default.orderBy(foundLinks, (link) => {
            var _a;
            return (_a = link.position) === null || _a === void 0 ? void 0 : _a.start.offset;
        }, "desc");
        // perform header updates as needed
        if (oldLoc.fname.toLowerCase() === newLoc.fname.toLowerCase() &&
            oldLoc.vaultName === newLoc.vaultName &&
            oldLoc.anchorHeader &&
            newLoc.anchorHeader) {
            // Renaming the header, only update links that link to the old header
            allLinks = lodash_1.default.filter(allLinks, (link) => {
                var _a, _b;
                // This is a wikilink to this header
                if (((_a = link.to) === null || _a === void 0 ? void 0 : _a.anchorHeader) === oldLoc.anchorHeader)
                    return true;
                // Or this is a range reference, and one part of the range includes this header
                return (link.type === "ref" &&
                    (0, common_all_1.isNotUndefined)(oldLoc.anchorHeader) &&
                    this.referenceRangeParts((_b = link.to) === null || _b === void 0 ? void 0 : _b.anchorHeader).includes(oldLoc.anchorHeader));
            });
        }
        // filter all links for following criteria:
        // - only modify links that have same _to_ vault name
        // - explicitly same: has vault prefix
        // - implicitly same: to.vaultName is undefined, but link is in a note that's in the vault.
        allLinks = allLinks.filter((link) => {
            var _a, _b;
            const oldLocVaultName = oldLoc.vaultName;
            const explicitlySameVault = ((_a = link.to) === null || _a === void 0 ? void 0 : _a.vaultName) === oldLocVaultName;
            const oldLocVault = common_all_1.VaultUtils.getVaultByName({
                vaults: this.vaults,
                vname: oldLocVaultName,
            });
            const implicitlySameVault = lodash_1.default.isUndefined((_b = link.to) === null || _b === void 0 ? void 0 : _b.vaultName) && lodash_1.default.isEqual(note.vault, oldLocVault);
            return explicitlySameVault || implicitlySameVault;
        });
        // perform link substitution
        lodash_1.default.reduce(allLinks, (note, link) => {
            var _a;
            const oldLink = unified_1.LinkUtils.dlink2DNoteLink(link);
            // current implementation adds alias for all notes
            // check if old note has alias thats different from its fname
            let alias;
            if (oldLink.from.alias && oldLink.from.alias !== oldLink.from.fname) {
                alias = oldLink.from.alias;
                // Update the alias if it was using the default alias.
                if (((_a = oldLoc.alias) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) ===
                    oldLink.from.alias.toLocaleLowerCase() &&
                    newLoc.alias) {
                    alias = newLoc.alias;
                }
            }
            // for hashtag links, we'll have to regenerate the alias
            if (newLoc.fname.startsWith(common_all_1.TAGS_HIERARCHY)) {
                const fnameWithoutTag = newLoc.fname.slice(common_all_1.TAGS_HIERARCHY.length);
                // Frontmatter tags don't have the hashtag
                if (link.type !== "frontmatterTag")
                    alias = `#${fnameWithoutTag}`;
                else
                    alias = fnameWithoutTag;
            }
            else if (oldLink.from.fname.startsWith(common_all_1.TAGS_HIERARCHY)) {
                // If this used to be a hashtag but no longer is, the alias is like `#foo.bar` and no longer makes sense.
                // And if this used to be a frontmatter tag, the alias being undefined will force it to be removed because a frontmatter tag can't point to something outside of tags hierarchy.
                alias = undefined;
            }
            // for user tag links, we'll have to regenerate the alias
            if (newLoc.fname.startsWith(common_all_1.USERS_HIERARCHY)) {
                const fnameWithoutTag = newLoc.fname.slice(common_all_1.USERS_HIERARCHY.length);
                alias = `@${fnameWithoutTag}`;
            }
            else if (oldLink.from.fname.startsWith(common_all_1.USERS_HIERARCHY)) {
                // If this used to be a user tag but no longer is, the alias is like `@foo.bar` and no longer makes sense.
                alias = undefined;
            }
            // Correctly handle header renames in references with range based references
            if (oldLoc.anchorHeader &&
                link.type === "ref" &&
                (0, common_all_1.isNotUndefined)(oldLink.from.anchorHeader) &&
                oldLink.from.anchorHeader.indexOf(":") > -1 &&
                (0, common_all_1.isNotUndefined)(newLoc.anchorHeader) &&
                newLoc.anchorHeader.indexOf(":") === -1) {
                // This is a reference, old anchor had a ":" in it, a new anchor header is provided and does not have ":" in it.
                // For example, `![[foo#start:#end]]` to `![[foo#something]]`. In this case, `something` is actually supposed to replace only one part of the range.
                // Find the part that matches the old header, and replace just that with the new one.
                let [start, end] = this.referenceRangeParts(oldLink.from.anchorHeader);
                if (start === oldLoc.anchorHeader)
                    start = newLoc.anchorHeader;
                if (end === oldLoc.anchorHeader)
                    end = newLoc.anchorHeader;
                newLoc.anchorHeader = `${start}:#${end}`;
            }
            const newBody = unified_1.LinkUtils.updateLink({
                note,
                oldLink,
                newLink: {
                    ...oldLink,
                    from: {
                        ...newLoc,
                        anchorHeader: newLoc.anchorHeader || oldLink.from.anchorHeader,
                        alias,
                    },
                },
            });
            note.body = newBody;
            return note;
        }, note);
        if (prevNote.body === note.body && prevNote.tags === note.tags) {
            return;
        }
        else {
            return note;
        }
    }
    referenceRangeParts(anchorHeader) {
        if (!anchorHeader || anchorHeader.indexOf(":") === -1)
            return [];
        let [start, end] = anchorHeader.split(":");
        start = start.replace(/^#*/, "");
        end = end.replace(/^#*/, "");
        return [start, end];
    }
}
exports.DendronEngineV3 = DendronEngineV3;
const createEngineV3 = ({ wsRoot }) => {
    const engine = DendronEngineV3.create({ wsRoot });
    return engine;
};
exports.createEngineV3 = createEngineV3;
//# sourceMappingURL=DendronEngineV3.js.map