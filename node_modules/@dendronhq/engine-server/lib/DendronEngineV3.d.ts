import { DEngine, DEngineClient, DEngineDeleteSchemaResp, DEngineInitResp, DEngineMode, DHookDict, DLink, DStore, DVault, EngineDeleteOpts, EngineInfoResp, EngineSchemaWriteOpts, EngineV3Base, EngineWriteOptsV2, FuseEngine, GetAnchorsRequest, GetDecorationsPayload, GetLinksRequest, GetNoteAnchorsPayload, GetNoteBlocksPayload, GetNoteLinksPayload, IFileStore, INoteStore, IntermediateDendronConfig, ISchemaStore, NoteProps, NotePropsByFnameDict, NotePropsByIdDict, NoteQueryResp, Optional, QueryNotesOpts, RenameNoteOpts, RenameNotePayload, RenderNotePayload, RespV2, RespV3, SchemaModuleDict, SchemaModuleProps, SchemaQueryResp, UpdateNoteResp, WorkspaceOpts, WriteNoteResp } from "@dendronhq/common-all";
import { DLogger } from "@dendronhq/common-server";
declare type DendronEngineOptsV3 = {
    wsRoot: string;
    vaults: DVault[];
    fileStore: IFileStore;
    noteStore: INoteStore<string>;
    schemaStore: ISchemaStore<string>;
    forceNew?: boolean;
    mode?: DEngineMode;
    logger?: DLogger;
    config: IntermediateDendronConfig;
};
declare type DendronEnginePropsV3 = Required<DendronEngineOptsV3>;
export declare class DendronEngineV3 extends EngineV3Base implements DEngine {
    wsRoot: string;
    store: DStore;
    protected props: DendronEnginePropsV3;
    fuseEngine: FuseEngine;
    links: DLink[];
    configRoot: string;
    config: IntermediateDendronConfig;
    hooks: DHookDict;
    private _vaults;
    private _fileStore;
    private _noteStore;
    private _schemaStore;
    static _instance: DendronEngineV3 | undefined;
    constructor(props: DendronEnginePropsV3);
    static create({ wsRoot, logger }: {
        logger?: DLogger;
        wsRoot: string;
    }): DendronEngineV3;
    static instance({ wsRoot }: {
        wsRoot: string;
    }): DendronEngineV3;
    /**
     * @deprecated
     * For accessing a specific note by id, see {@link DendronEngineV3.getNote}.
     * If you need all notes, avoid modifying any note as this will cause unintended changes on the store side
     */
    get notes(): NotePropsByIdDict;
    /**
     * @deprecated see {@link DendronEngineV3.findNotes}
     */
    get noteFnames(): NotePropsByFnameDict;
    /**
     * @deprecated
     * For accessing a specific schema by id, see {@link DendronEngineV3.getSchema}.
     * If you need all schemas, avoid modifying any schema as this will cause unintended changes on the store side
     */
    get schemas(): SchemaModuleDict;
    get vaults(): DVault[];
    set vaults(vaults: DVault[]);
    /**
     * Does not throw error but returns it
     */
    init(): Promise<DEngineInitResp>;
    /**
     * See {@link DEngine.writeNote}
     */
    writeNote(note: NoteProps, opts?: EngineWriteOptsV2): Promise<WriteNoteResp>;
    /**
     * See {@link DEngine.renameNote}
     *
     * TODO: make atomic
     */
    renameNote(opts: RenameNoteOpts): Promise<RespV2<RenameNotePayload>>;
    /**
     * TODO: We should read config from file or from engine.config, not both.
     */
    getConfig(): Promise<RespV2<IntermediateDendronConfig>>;
    /**
     * See {@link DEngine.getSchema}
     */
    getSchema(id: string): Promise<RespV3<SchemaModuleProps>>;
    /**
     * See {@link DEngine.writeSchema}
     */
    writeSchema(schema: SchemaModuleProps, opts?: EngineSchemaWriteOpts): Promise<void>;
    /**
     * See {@link DEngine.deleteSchema}
     */
    deleteSchema(id: string, opts?: EngineDeleteOpts): Promise<DEngineDeleteSchemaResp>;
    info(): Promise<RespV2<EngineInfoResp>>;
    queryNotesSync(): ReturnType<DEngineClient["queryNotesSync"]>;
    /**
     * See {@link DEngine.querySchema}
     */
    querySchema(queryString: string): Promise<SchemaQueryResp>;
    /**
     * See {@link DEngine.queryNotes}
     */
    queryNotes(opts: QueryNotesOpts): Promise<NoteQueryResp>;
    renderNote(): Promise<RespV2<RenderNotePayload>>;
    sync(): Promise<never>;
    refreshNotes(): Promise<RespV2<void>>;
    /**
     * @deprecated: Use {@link DEngine.writeNote}
     */
    updateNote(): Promise<UpdateNoteResp>;
    /**
     * @deprecated: Use {@link DEngine.writeSchema}
     */
    updateSchema(): Promise<void>;
    writeConfig(): ReturnType<DEngine["writeConfig"]>;
    addAccessTokensToPodConfig(): Promise<void>;
    getNoteBlocks(): Promise<GetNoteBlocksPayload>;
    getDecorations(): Promise<GetDecorationsPayload>;
    /**
     * @deprecated: Use {@link LinkUtils.findLinks}
     */
    getLinks(opts: Optional<GetLinksRequest, "ws">): Promise<GetNoteLinksPayload>;
    /**
     * @deprecated: Use {@link AnchorUtils.findAnchors}
     */
    getAnchors(opts: GetAnchorsRequest): Promise<GetNoteAnchorsPayload>;
    private initSchema;
    /**
     * Construct dictionary of NoteProps from workspace on filesystem
     *
     * For every vault on the filesystem, get list of files and convert each file to NoteProp
     * @returns NotePropsByIdDict
     */
    private initNotes;
    /**
     * Create and add backlinks from all notes with a link pointing to another note
     */
    private addBacklinks;
    /**
     * Recursively search through fname to find next available ancestor note.
     *
     * E.g, if fpath = "baz.foo.bar", search for "baz.foo", then "baz", then "root" until first valid note is found
     * @param fpath of note to find ancestor of
     * @param vault of ancestor note
     * @returns closest ancestor note
     */
    private findClosestAncestor;
    /**
     * Update the links inside this note that need to be updated for the rename from `oldLoc` to `newLoc`
     * Will update the note in place and return note if something has changed
     */
    private processNoteChangedByRename;
    private referenceRangeParts;
}
export declare const createEngineV3: ({ wsRoot }: WorkspaceOpts) => DEngineClient;
export {};
